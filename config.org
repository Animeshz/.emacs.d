#+TITLE: My Literate Emacs Configuration
#+STARTUP: overview
#+EXPORT_FILE_NAME: index.html
#+PROPERTIES: header-args :lexical t

* Preliminaries

** Preface

I was first introduced to Emacs by a friend at my college. I had been resistant to a lot of things in my life, like the
4-finger claw for playing mobile games, 10-finger touch typing on laptops, learning vim keybindings, and this time,
Emacs. I can only count how many times these things have saved me from a time-bubble burst. These seemingly obscure and
optional(-looking) things have indeed proven to be a few of the most influential aspects of my life.

[[https://www.csee.umbc.edu/resources/computer-science-help-center/resources-for-new-students/an-introduction-to-emacs][Emacs]] holds a special place at the nucleus of my technological toolkit. All my workflows simplify down, because of its
indcredible ingrained & integrable plugin ecosystem. You can't imagine any other software working so well for a variety
of use cases, sometimes even better than their recommended options. It has elevated my workflow as a programmer to a
whole new level.

** Introduction

This file, even though looking like a documentation or a book is indeed my emacs configuration!
(And also my ever updating notes while I'm learning emacs).

This is possible because of the org-babel plugin (inbuilt in Emacs as of now) that allows Emacs to contain code-blocks
within the org-mode documents. And this style of writing code within natural language is known as Literate Programming.

You can view my configuration at:
- [[https://animeshz.github.io/.emacs.d/][Website]]
- [[https://github.com/Animeshz/.emacs.d][GitHub]]

* Getting Started

** Installation

Install as you wish, I prefer using nix + home-manager for installation.

#+BEGIN_SRC nix :tangle no
{ pkgs }:
{
  programs.emacs = {
    enable = true;
    package = pkgs.emacs29;

    extraPackages = epkgs: with epkgs; with pkgs; [
      custom.emacs-pcre
      custom.emacs-chdir
    ];
  };
}
#+END_SRC

I export emacs-pcre and emacs-chdir as custom packages on my [[https://github.com/Animeshz/linux-desktop][nix config]].

** Basic Keybinds

I like to remember a few keybinds so in-case my config had any error, I could still use emacs with these fallback
keybinds. And these keybinds are in general good enough for my hands as well hence I mostly don't change them.

- C = Ctrl
- M = Alt
- S = Shift

| Scope      | Keybind                | Action                                                      |
|------------+------------------------+-------------------------------------------------------------|
| global     | M-x                    | View Available Commands                                     |
|            | C-x C-f                | Find File                                                   |
|            | C-h [f / v / k]        | Help on [functions / variables / key-chords]                |
|            | C-x [2 / 3 / 0 / 1]    | Window Split [Down / Right / Close / Close All Except This] |
|            | C-x o / C-w C-w (Evil) | Switch Window Split                                         |
| org-mode   | C-c C-c                | Run CodeBlock or Format Table                               |
|            | C-c C-l                | Insert Link                                                 |
|            | C-c C-,                | Insert Snippets                                             |
| minibuffer | C-y                    | Paste                                                       |

=M-<number>= is a shorthand for =C-u <number>=, and is used to pass first argument =number= in interactive commands
via M-x or keybind.

** Tutorials

I like to recommend [[https://www.youtube.com/watch?v=B6jfrrwR10k][this video]] if you want to get familiarized with emacs! This packs a lot of information with
effective presentations instead of most videos which talk way too much and delivers barely anything useful.

[[https://www.youtube.com/playlist?list=PLlHHtPGox8K6bcuruX10Evf4AYGzYQKiz][This playlist]] is good for getting quick short videos for further learning emacs on your own pace.

* Emacs Configuration

** Early-Init and Init

The [[./early-init.el][early-init.el]] and [[./init.el][init.el]] files are the first two files emacs read when starting up.

I kept them separated from this main configuration because the former do very naive stuffs
(such as basic ui changes and performance optimization), and the latter contains bootstrap code for Elpaca the package
manager which is a prerequisite for most of this config and also it loads this config in the end.

** Better Defaults (Almost Mandatory)

Emacs requires some essential tweaks to become somewhat usable.

#+BEGIN_SRC emacs-lisp
;;; This file is generated from config.org | -*- lexical-binding: t; -*-

;; Enable minibuffer history, prioritizes M-x & vim commands with most recent commands issued
(setq history-length 100)
(savehist-mode 1)

;; Enable recording recent files & window configuration for going back and forth
(recentf-mode 1)  ; SPC-f-r
(winner-mode 1)   ; C-c [left / right]

;; Set relative lines
(setq display-line-numbers-type 'relative)
(global-display-line-numbers-mode t)

;; Configure automatic line breaks and word-wrap (just in case)
(setq-default fill-column 120  ; SPC-c
              auto-fill-function 'do-auto-fill)
(global-visual-line-mode t)  ; SPC-w

;; I prefer indentation with spaces
(setq-default tab-width 4
              indent-tabs-mode nil)

;; Make scratch buffer text-mode
(setq-default initial-scratch-message nil
              initial-major-mode 'text-mode)

;; Replace yes/no with y/n
(setq use-short-answers t)

;; Modeline
(column-number-mode 1)
#+END_SRC

** Better Org-Mode Defaults

Same goes for =org-mode=.

#+BEGIN_SRC emacs-lisp
;; Allow these languages for code evaluation in org-mode documents
(org-babel-do-load-languages 'org-babel-load-languages
                             '((emacs-lisp . t) (shell . t) (python . t) (ruby . t) (C . t) (js . t)))  ; C-c C-c

;; Give org html export a deterministic id so it doesn't pollute git history
(defun my/org-deterministic-reference (references)
  (cl-loop for new from (length references) until (not (rassq new references))
           finally return new))
(advice-add #'org-export-new-reference :override #'my/org-deterministic-reference)
#+END_SRC

** Base Packages

These core packages are the scaffold upon which the entire configuration below is assembled.

#+BEGIN_SRC emacs-lisp
;; Used to set keybinds
(use-package general
  :config
  (general-override-mode)
  (general-auto-unbind-keys))

;; Emulates vim keybinds & modal editing
(use-package evil
  :init
  (setq evil-v$-excludes-newline t       ; $ in visual doesn't include \n
        evil-kill-on-visual-paste nil    ; pasting in visual mode won't copy replaced text to clipboard
        evil-auto-indent nil             ; o and O doesn't add indents
        evil-cross-lines t               ; h and l to move to newline
        ;; evil-respect-visual-line-mode t  ; physical line as $ anchor instead of \n, caveat: dj dk doesn't work as intended
        evil-shift-width tab-width       ; << and >>
        evil-want-keybinding nil         ; required by =evil-collection=
        evil-split-window-below t
        evil-vsplit-window-right t)
  :config
  (evil-mode 1))

;; Extend support of vim keybindings on to various other packages
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))

(elpaca-wait)
#+END_SRC

The =evil= package provides Vim's Modal Editing in Emacs. I have notes on [[https://animeshz.github.io/site/notes/20-29--DevEnvironment/21--Linux/21.03-Cli-Utilities.html#n-vim][the only Vim keybind you need to know]] on my
site.

** Set Fonts

Set global font, whichever is available in the =preferred-fonts=.

#+BEGIN_SRC emacs-lisp
(defvar preferred-fonts
  (list "CaskaydiaCove Nerd Font Mono" "Fira Code Mono" "Jetbrains Mono"))

(custom-set-faces
 '(default ((t (:family (cl-find-if font-info preferred-fonts) :height 120)))))
#+END_SRC

I didn't set =variable-pitch= and =fixed-pitch= faces separately and forced Mono font everywhere, although that's also
an option.

** Set Keybinds

General keybinds which are not specific to any package.

With evil we have 2 things, evil states (namely normal, motion, visutal, etc) and mode-map. In emacs, everything we edit
(the buffer) has a major mode (e.g. prog-mode) and multiple minor modes (e.g. winner-mode, rust-mode) enabled through
file extension or hooks, each of these modes have a mode-map associated in order to set keybinds in buffers with those
modes enabled. Read more about them [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Modes.html][here]].

*** Normal Keybinds

Keybinds without prefix.

#+BEGIN_SRC emacs-lisp
(general-def '(normal motion visual operator)
  ;; Adjust font size
  "C-+" #'text-scale-increase
  "C-_" #'text-scale-decrease

  ;; Move lines without moving cursor
  "," #'evil-scroll-line-down
  "." #'evil-scroll-line-up

  ;; Indent region (same keybind as vscode lol)
  "C-S-i" '(lambda () (interactive) (indent-region (point-min) (point-max)))

  "<escape>" #'keyboard-escape-quit)
#+END_SRC

*** Leader Keybinds

Keybinds with =SPC= prefix.

#+BEGIN_SRC emacs-lisp
(general-create-definer leader-key
  :states '(normal motion visual operator emacs)
  :keymaps 'override
  :prefix "SPC")

(leader-key
  "ff" #'find-file
  "fr" #'recentf-open
  "tw" #'delete-trailing-whitespace
  "ev" #'eval-region
  "x" #'kill-this-buffer
  "r" #'revert-buffer
  "c" #'display-fill-column-indicator-mode
  "s" #'switch-to-buffer
  "d" #'bookmark-jump
  "w" #'visual-line-mode  ; toggle word-wrap
  "p" #'projectile-command-map
  "/" #'comment-dwim)
#+END_SRC

*** Miscellaneous

Ergonomic UX on insert-like modes,

#+BEGIN_SRC emacs-lisp
(general-def 'insert
  "<tab>" #'tab-to-tab-stop
  "C-S-v" #'evil-paste-before-cursor-after)

(general-def '(isearch-mode-map)
  "C-S-v" #'isearch-yank-kill)

(general-def '(minibuffer-mode-map)
  "C-S-v" #'yank)
#+END_SRC

Some org mode enhancements

#+BEGIN_SRC emacs-lisp
;; Toggle folding org headings with tab/ret
(general-def 'normal org-mode-map
  "<tab>" #'evil-toggle-fold
  "<RET>" '(lambda ()
             (interactive)
             (cond
              ((org-at-heading-p) (evil-toggle-fold))
              ((org-in-regexp org-link-any-re) (org-open-at-point))
              (t (evil-ret)))))
#+END_SRC

* Productivity Enhancers

** Undo History

Preserving undo history is probably the first productivity enhancer I can think of.

#+BEGIN_SRC emacs-lisp
;; keep undo history
(use-package undo-fu
  :config
  (general-setq evil-undo-system 'undo-fu))

;; keep file's undo history between emacs sessions
(use-package undo-fu-session
  :config
  (undo-fu-session-global-mode))

;; make undo history a tree on-the-fly
(use-package vundo
  :ensure (vundo :host github :repo "casouri/vundo")
  :config
  (general-def 'normal vundo-mode-map "<escape>" #'vundo-quit))
#+END_SRC

** Key & Minibuffer completions

This is really important as my memory is dum dum.

#+BEGIN_SRC emacs-lisp
;; Shows valid key combinations after a key-press
(use-package which-key
  :config
  (setq which-key-idle-delay 0.4)
  (which-key-mode))
#+END_SRC

Completion over M-x and other help panels.

#+BEGIN_SRC emacs-lisp
;; Transforms prompts into selectable panels
(use-package vertico
  :config
  (setq vertico-count 20
        vertico-resize nil
        vertico-cycle t)
  (vertico-mode))

;; Allows partial, unordered and regex search on those panels
(use-package orderless
  :config
  (setq completion-styles '(orderless basic)))
#+END_SRC

** Hop (Jump Anywhere on Buffer)

This was my most missing feature from nvim, so much so I wrote this package myself. Read more on [[https://github.com/Animeshz/hop.el][hop.el]].

#+BEGIN_SRC emacs-lisp
(require 'pcre)

(use-package hop
  :ensure (hop :host github :repo "Animeshz/hop.el")
  :config
  (general-def '(normal motion visual operator)
    "go" #'hop-word
    "gl" #'hop-char
    "gp" #'hop-regex-pattern
    "gk" #'hop-line))
#+END_SRC

** AutoCompletion & Snippets

Woah, now we want to speed up!

#+BEGIN_SRC emacs-lisp
;; Inline completions frontend
(use-package company
  :config
  (setq company-idle-delay 0
        company-show-numbers t)
  (global-company-mode 1))
#+END_SRC

Now let's add a few completion backends.

#+BEGIN_SRC emacs-lisp
;; Tabnine is my choice!
(use-package company-tabnine)

;; Add snippets to the stack!
(use-package yasnippet
  :config
  (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
  (leader-key "ns" #'yas-new-snippet)
  (yas-global-mode 1))
#+END_SRC

Setup company at the end of everything, so multiple backends can be grouped and prioritized.

#+BEGIN_SRC emacs-lisp
(defun setup-company ()
  (setq company-backends '((company-yasnippet))))
(add-hook 'elpaca-after-init-hook #'setup-company)

;; Tabnine may not sometimes keep up with my typing speed, so I may wanna toggle it often with SPC-t-n
(defun toggle-tabnine ()
  (interactive)
  (setq company-backends
        (cond ((equal company-backends '((company-yasnippet))) '((company-tabnine :with company-yasnippet)))
              (t '((company-yasnippet))))))
(leader-key
  "tn" #'toggle-tabnine)
#+END_SRC

* Integrations

** Remote Execution

* Programming

** Parinfer (Lisp Auto-Parenthesis)

#+BEGIN_SRC emacs-lisp
;; (use-package parinfer-rust-mode
;;   :hook '(emacs-lisp-mode)
;;   :init
;;   (setq parinfer-rust-auto-download t)
;;   (setq parinfer-rust-troublesome-modes nil)
;;   :config
;;   (defun my-enable-minor-mode-for-special-file ()
;;     "Enable my-minor-mode for my-special-file.txt."
;;     (message "%s" (buffer-name))
;;     (when (string= (buffer-name) "config.org")
;;       (parinfer-rust-mode)))
;;   (add-hook 'find-file-hook 'my-enable-minor-mode-for-special-file))
#+END_SRC

** Highlighting

#+BEGIN_SRC emacs-lisp
;; (use-package nix-mode
;;   :mode "\\.nix\\'")
(use-package markdown-mode
  :mode "\\.md\\'")
;; (use-package kotlin-mode
;;   :mode "\\.kt\\|\\.kts\\'")
#+END_SRC

** AutoCompletion, CodeActions & Snippets

#+BEGIN_SRC emacs-lisp
;; (use-package projectile
;;   :init
;;   (projectile-mode +1)
;;   :config
;;   (define-key projectile-command-map (kbd "ESC") 'keyboard-escape-quit))

;; (use-package corfu
;;   :ensure (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*.el"))
;;   :config
;;   ;; Setup corfu for popup like completion
;;   (setq corfu-cycle t  ; Allows cycling through candidates
;;         corfu-auto t   ; Enable auto completion
;;         corfu-auto-prefix 0  ; Complete with less prefix keys
;;         corfu-auto-delay 0.0  ; No delay for completion
;;         corfu-echo-documentation t ; Echo docs for current completion option
;;         corfu-popupinfo-delay 0.0
;;         corfu-quit-no-match 'separator
;;         corfu-quit-at-boundary 'insert)

;;   ;; Silence the pcomplete capf, no errors or messages!
;;   (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

;;   ;; Ensure that pcomplete does not write to the buffer
;;   ;; and behaves as a pure `completion-at-point-function'.
;;   (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
;;   (global-corfu-mode 1)
;;   (corfu-popupinfo-mode 1))
#+END_SRC

** LSP

#+BEGIN_SRC emacs-lisp
;; (use-package eglot
;;   :hook (prog-mode . eglot-ensure)
;;   :config
;;   (setq debug-on-error nil)
;;   (add-to-list 'eglot-server-programs '(kotlin-mode . ("kotlin-language-server")))
;;   (define-key eglot-mode-map (kbd "C-c r") 'eglot-rename)
;;   (define-key eglot-mode-map (kbd "C-c o") 'eglot-code-action-organize-imports)
;;   (define-key eglot-mode-map (kbd "C-c h") 'eldoc)
;;   (define-key eglot-mode-map (kbd "<f6>") 'xref-find-definitions))
#+END_SRC

** Mermaid/GraphViz (Graph)

#+BEGIN_SRC emacs-lisp
(use-package mermaid-mode)
(use-package ob-mermaid
  :config
  (add-hook 'org-babel-after-execute-hook (lambda ()
                                            (org-redisplay-inline-images)))
  (setq org-startup-with-inline-images t)
  (setq org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages 'org-babel-load-languages '((mermaid . t))))

(use-package graphviz-dot-mode
  :config
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t))))

(use-package ob-svgbob)
#+END_SRC

* Add-ons

** Embark

This is [[https://karthinks.com/software/fifteen-ways-to-use-embark][great article]] on uses of Embark.

It makes minibuffer as flexible as normal buffer is.

#+BEGIN_SRC emacs-lisp
(use-package embark
  :config
  (setq embark-quit-after-action nil)
  (general-def '(normal motion visual global)
    "C-."  #'embark-act
    "C-;"  #'embark-export))
#+END_SRC

Most useful actions on =embark-act=

| Scope  | Keybind | Action                             |
|--------+---------+------------------------------------|
| global | C-h     | Expand all actions                 |
|        | i       | Insert minibuffer candidate        |
| M-x    | g       | Set keybind to command for session |

** Marginalia

Add extra information on minibuffers.

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :config
  (setq marginalia-align 'center)
  (marginalia-mode))
#+END_SRC

** Better Help

#+BEGIN_SRC emacs-lisp
;; Setup better help
(use-package helpful
  :config
  ;; Remap C-h to helpful package
  (general-define-key
   :prefix "C-h"
   "f" #'helpful-callable
   "v" #'helpful-variable
   "k" #'helpful-key
   "F" #'helpful-function
   "C" #'helpful-command))
#+END_SRC

** Chdir Support

Syncing /proc/self/cwd with changes to (default-directory).

#+BEGIN_SRC emacs-lisp
(require 'chdir)
#+END_SRC

* Look & Feel

** Theme

The main theme when opening emacs.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (global-hl-line-mode 1)
  (doom-themes-visual-bell-config)
  (load-theme 'doom-city-lights t)
  (custom-set-faces
   '(doom-themes-visual-bell ((t (:background "#00FFFF"))))
   '(org-ellipsis ((t (:foreground "#C678DD"))))))
#+END_SRC

** Org Export

Theme of the exported website when running =org-html-export-to-html=, this copies theme that is applied above.

#+BEGIN_SRC emacs-lisp
(use-package hexrgb
  :ensure
  (hexrgb :host github :repo "emacsmirror/hexrgb" :main "hexrgb.el"))

(use-package org-html-themify
  :after hexrgb
  :ensure
  (org-html-themify
   :host github
   :repo "DogLooksGood/org-html-themify"
   :files ("*.el" "*.js" "*.css"))
  :hook (org-mode . org-html-themify-mode)
  :config
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0))
#+END_SRC

** Highlight Todo

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook ((prog-mode org-mode) . hl-todo-mode)
  :init
  (setq hl-todo-keyword-faces '(("HOLD" . "#cfdf30")
                                ("TODO" . "#ff9977")
                                ("NEXT" . "#b6a0ff")
                                ("PROG" . "#00d3d0")
                                ("FIXME" . "#ff9977")
                                ("DONE" . "#44bc44")
                                ("REVIEW" . "#6ae4b9")
                                ("DEPRECATED" . "#bfd9ff"))))
#+END_SRC

* Miscellaneous

** Don't reset the cursor to the middle when scrolling

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(scroll-conservatively 200)
 '(scroll-margin 3))
#+END_SRC

** Highlight Trailing Whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
(add-hook 'prog-mode-hook
          (lambda () (font-lock-add-keywords nil '(("\\s-+$" 0 'trailing-whitespace)))))
#+END_SRC

** Don't affect previous line with C-backspace

#+BEGIN_SRC emacs-lisp
(defun my/backward-kill-word ()
  "Kill backward to the beginning of the current word, but do not cross lines."
  (interactive)
  (if (not (looking-back "^\\s-*")) (backward-kill-word 1) (delete-horizontal-space)))

(global-set-key (kbd "<C-backspace>") 'my/backward-kill-word)
#+END_SRC

** Change backup file dump path

#+BEGIN_SRC emacs-lisp
(defvar user-temporary-file-directory
  (concat temporary-file-directory user-login-name "/"))
(make-directory user-temporary-file-directory t)
(setq backup-by-copying t)
(setq backup-directory-alist
      `(("." . ,user-temporary-file-directory)
        (,tramp-file-name-regexp nil)))
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))
#+END_SRC

** Window Split Vertical-Horizontal Toggle

#+BEGIN_SRC emacs-lisp
(defun window-split-toggle ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (> (length (window-list)) 2)
      (error "Can't toggle with more than 2 windows!")
    (let ((func (if (window-full-height-p)
                    #'split-window-vertically
                  #'split-window-horizontally)))
      (delete-other-windows)
      (funcall func)
      (save-selected-window
        (other-window 1)
        (switch-to-buffer (other-buffer))))))
(leader-key
  "ts" #'window-split-toggle)
#+END_SRC

** open-at-point that opens respecting OS's default app for the link

#+BEGIN_SRC emacs-lisp
(defun open-at-point ()
  "Open URL at point."
  (interactive)
  (let* ((link-regexp "\\[\\[\\(.*?\\)\\]\\[.*?\\]\\]")
         (link (save-excursion
                 (when (re-search-backward link-regexp nil t)
                   (match-string 1)))))
    (message "%s" link)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" link t t)))
     ((string-equal system-type "darwin")
      (shell-command (format "open \"%s\"" link)))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" link))))))
#+END_SRC

** File closing prompt with evil-quit without saving won't show "Type C-h for help." in case wrong key is pressed.

Redefining the funcion at emacs/lisp/emacs-lisp/map-ynp.el, with some lines commented out.

#+BEGIN_SRC emacs-lisp
(defun map-y-or-n-p (prompter actor list &optional help action-alist
                              no-cursor-in-echo-area)
  "Ask a boolean question per PROMPTER for each object in LIST, then call ACTOR.

      LIST is a list of objects, or a function of no arguments to return the next
      object; when it returns nil, the list of objects is considered exhausted.

      If PROMPTER is a string, it should be a format string to be used to format
      the question as \(format PROMPTER OBJECT).
      If PROMPTER is not a string, it should be a function of one argument, an
      object from LIST, which returns a string to be used as the question for
      that object.  If the function's return value is not a string, it may be
      nil to ignore the object, or non-nil to act on the object with ACTOR
      without asking the user.

      ACTOR is a function of one argument, an object from LIST,
      which gets called with each object for which the user answers `yes'
      to the question presented by PROMPTER.

      The user's answers to the questions may be one of the following:

       - y, Y, or SPC to act on that object;
       - n, N, or DEL to skip that object;
       - ! to act on all following objects;
       - ESC or q to exit (skip all following objects);
       - . (period) to act on the current object and then exit; or
       - \\[help-command] to get help.

      HELP provides information for displaying help when the user
      types \\[help-command].  If HELP is given, it should be a list of
      the form (OBJECT OBJECTS ACTION), where OBJECT is a string giving
      the singular noun describing an element of LIST; OBJECTS is the
      plural noun describing several elements of LIST, and ACTION is a
      transitive verb describing action by ACTOR on one or more elements
      of LIST.  If HELP is omitted or nil, it defaults
      to \(\"object\" \"objects\" \"act on\").

      If ACTION-ALIST is given, it is an alist specifying additional keys
      that will be accepted as an answer to the questions.  Each element
      of the alist has the form (KEY FUNCTION HELP), where KEY is a character;
      FUNCTION is a function of one argument (an object from LIST); and HELP
      is a string.  When the user presses KEY, FUNCTION is called; if it
      returns non-nil, the object is considered to have been \"acted upon\",
      and `map-y-or-n-p' proceeds to the next object from LIST.  If
      FUNCTION returns nil, the prompt is re-issued for the same object: this
      comes in handy if FUNCTION produces some display that will allow the
      user to make an intelligent decision whether the object in question
      should be acted upon.  If the user types \\[help-command], the string
      given by HELP is used to describe the effect of KEY.

      Optional argument NO-CURSOR-IN-ECHO-AREA, if non-nil, means not to set
      `cursor-in-echo-area' while prompting with the questions.

      This function uses `query-replace-map' to define the standard responses,
      but only some of the responses which `query-replace' understands
      are meaningful here, as described above.

      The function's value is the number of actions taken."
  (let* ((actions 0)
         (msg (current-message))
         user-keys mouse-event map prompt char elt def
         ;; Non-nil means we should use mouse menus to ask.
         use-menus
         delayed-switch-frame
         ;; Rebind other-window-scroll-buffer so that subfunctions can set
         ;; it temporarily, without risking affecting the caller.
         (other-window-scroll-buffer other-window-scroll-buffer)
         (next (if (functionp list)
                   (lambda () (setq elt (funcall list)))
                 (lambda () (when list
                              (setq elt (pop list))
                              t))))
         (try-again (lambda ()
                      (let ((x next))
                        (setq next (lambda () (setq next x) elt))))))
    (if (and (listp last-nonmenu-event)
             use-dialog-box)
        ;; Make a list describing a dialog box.
        (let ((objects (if help (capitalize (nth 1 help))))
              (action (if help (capitalize (nth 2 help)))))
          (setq map `(("Yes" . act) ("No" . skip)
                      ,@(mapcar (lambda (elt)
                                  (cons (with-syntax-table
                                            text-mode-syntax-table
                                          (capitalize (nth 2 elt)))
                                        (vector (nth 1 elt))))
                                action-alist)
                      (,(if help (concat action " This But No More")
                          "Do This But No More") . act-and-exit)
                      (,(if help (concat action " All " objects)
                          "Do All") . automatic)
                      ("No For All" . exit))
                use-menus t
                mouse-event last-nonmenu-event))
      (setq user-keys (if action-alist
                          (concat (mapconcat (lambda (elt)
                                               (key-description
                                                (vector (car elt))))
                                             action-alist ", ")
                                  " ")
                        "")
            ;; Make a map that defines each user key as a vector containing
            ;; its definition.
            map
            (let ((map (make-sparse-keymap)))
              (set-keymap-parent map query-replace-map)
              (dolist (elt action-alist)
                (define-key map (vector (car elt)) (vector (nth 1 elt))))
              map)))
    (unwind-protect
        (progn
          (if (stringp prompter)
              (setq prompter (let ((prompter prompter))
                               (lambda (object)
                                 (format prompter object)))))
          (while (funcall next)
            (setq prompt (funcall prompter elt))
            (cond ((stringp prompt)
                   ;; Prompt the user about this object.
                   (setq quit-flag nil)
                   (if use-menus
                       (setq def (or (x-popup-dialog (or mouse-event use-menus)
                                                     (cons prompt map))
                                     'quit))
                     ;; Prompt in the echo area.
                     (let ((cursor-in-echo-area (not no-cursor-in-echo-area)))
                       (message (apply 'propertize "%s(y, n, !, ., q, %sor %s) "
                                       minibuffer-prompt-properties)
                                prompt user-keys
                                (key-description (vector help-char)))
                       (if minibuffer-auto-raise
                           (raise-frame (window-frame (minibuffer-window))))
                       (while (progn
                                (setq char (read-event))
                                ;; If we get -1, from end of keyboard
                                ;; macro, try again.
                                (equal char -1)))
                       ;; Show the answer to the question.
                       (message "%s(y, n, !, ., q, %sor %s) %s"
                                prompt user-keys
                                (key-description (vector help-char))
                                (single-key-description char)))
                     (setq def (lookup-key map (vector char))))
                   (cond ((eq def 'exit)
                          (setq next (lambda () nil)))
                         ((eq def 'act)
                          ;; Act on the object.
                          (funcall actor elt)
                          (setq actions (1+ actions)))
                         ((eq def 'skip))
                         ;; Skip the object.

                         ((eq def 'act-and-exit)
                          ;; Act on the object and then exit.
                          (funcall actor elt)
                          (setq actions (1+ actions)
                                next (lambda () nil)))
                         ((eq def 'quit)
                          (setq quit-flag t)
                          (funcall try-again))
                         ((eq def 'automatic)
                          ;; Act on this and all following objects.
                          (if (funcall prompter elt)
                              (progn
                                (funcall actor elt)
                                (setq actions (1+ actions))))
                          (while (funcall next)
                            (if (funcall prompter elt)
                                (progn
                                  (funcall actor elt)
                                  (setq actions (1+ actions))))))
                         ((eq def 'help)
                          (with-help-window (help-buffer)
                            (princ
                             (let ((object  (or (nth 0 help) "object"))
                                   (objects (or (nth 1 help) "objects"))
                                   (action  (or (nth 2 help) "act on")))
                               (concat
                                (format-message
                                 (substitute-command-keys "\
      Type \\`SPC' or \\`y' to %s the current %s;
      \\`DEL' or \\`n' to skip the current %s;
      \\`RET' or \\`q' to skip the current and all remaining %s;
      \\`C-g' to quit (cancel the whole command);
      \\`!' to %s all remaining %s;\n")
                                 action object object objects action objects)
                                (mapconcat (lambda (elt)
                                             (format "%s to %s;\n"
                                                     (single-key-description
                                                      (nth 0 elt))
                                                     (nth 2 elt)))
                                           action-alist
                                           "")
                                (format
                                 "or . (period) to %s the current %s and exit."
                                 action object)))))

                          (funcall try-again))
                         ((and (symbolp def) (commandp def))
                          (call-interactively def)
                          ;; Regurgitated; try again.
                          (funcall try-again))
                         ((vectorp def)
                          ;; A user-defined key.
                          (if (funcall (aref def 0) elt) ;Call its function.
                              ;; The function has eaten this object.
                              (setq actions (1+ actions))
                            ;; Regurgitated; try again.
                            (funcall try-again)))
                         ((and (consp char)
                               (eq (car char) 'switch-frame))
                          ;; switch-frame event.  Put it off until we're done.
                          (setq delayed-switch-frame char)
                          (funcall try-again))))
                  ;; (t
                  ;; Random char.
                  ;; (message "Type %s for help."
                  ;;      (key-description (vector help-char)))
                  ;; (beep)
                  ;; (sit-for 1)
                  ;; (funcall try-again))))
                  (prompt
                   (funcall actor elt)
                   (setq actions (1+ actions))))))
      (if delayed-switch-frame
          (setq unread-command-events
                (cons delayed-switch-frame unread-command-events))))
    ;; Clear the last prompt from the minibuffer, and restore the
    ;; previous echo-area message, if any.
    (let ((message-log-max nil))
      (if msg
          (message "%s" msg)
        (message "")))
    ;; Return the number of actions that were taken.
    actions))
#+END_SRC

* Resources References

These resources were very helpful in formation of my config. So a huge phrase of appreciation to all those people who were part of this.

- [[https://opensource.com/sites/default/files/gated-content/cheat_sheet_emacs.pdf][Emacs Cheatsheet - Opensource.com]]
- [[https://github.com/progfolio/.emacs.d][Progfolio's Emacs Config (Creator of Elpaca package manager we're currently using)]]
- [[https://github.com/aadi58002/emacs-config/blob/main/init.org][Aadi58002's Emacs Config (My classmate, been known for the Emacs user of our batch)]].
- [[https://www.lucacambiaghi.com/vanilla-emacs/readme.html][Luca's Emacs Config]] & [[https://www.karsdorp.io/posts/dotemacs/][Karsdorp's Emacs Config]] - Long list of useful options to use, like a reference-book!
- [[https://www.reddit.com/r/emacs/comments/18bg0vc/more_advanced_emacs_tutorials][More advanced Emacs tutorials (Reddit)]].
- [[https://www.youtube.com/@howardabrams1][Howard Abrams (YT)]].
