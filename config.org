#+TITLE: Main Emacs Config (after early-init.el and init.el)
#+PROPERTIES: header-args :lexical t

* General Tweaks

** Better Defaults (Mandatory)

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t
      org-export-preserve-breaks t)

(setq history-length 100)
(savehist-mode 1)
(recentf-mode 1)

(setq use-short-answers t)
(setq electric-pair-mode t)     ; Auto add closing braces with opening
(global-visual-line-mode t)     ; Word Wrap

(setq-default fill-column 120)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))

(global-display-line-numbers-mode t)
(setq display-line-numbers-type 'relative)

(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
(setq-default evil-shift-width tab-width)
#+END_SRC

** Org Load Languages

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages
  '((shell . t)))
#+END_SRC

** Set Keybinds

#+BEGIN_SRC emacs-lisp :noweb-ref general-config :tangle no
(general-define-key
 :states '(insert motion)
 :keymaps '(local global)

 "C-S-v" 'evil-paste-before-cursor-after
 "TAB" 'tab-to-tab-stop)

(general-define-key
  :keymaps '(isearch-mode-map)  ; evil-search (/)

  "C-S-v" 'isearch-yank-kill)

(general-define-key
 :states 'insert
 "C-s" 'tempel-complete)
(general-define-key
 :states '(insert normal)
 :keymaps 'tempel-map
 "S-TAB" 'tempel-previous
 "TAB" 'tempel-next)

(general-define-key
 :states '(normal motion visual operator emacs)
 :keymaps '(override local global)

 "H" 'evil-beginning-of-line
 "J" 'evil-goto-line
 "K" 'evil-goto-first-line
 "L" 'evil-end-of-line

 "," 'evil-scroll-line-down
 "." 'evil-scroll-line-up

 "C-+" 'text-scale-increase
 "C-_" 'text-scale-decrease
 "C--" 'text-scale-decrease
 "C-S-i" '(lambda () (interactive) (indent-region (point-min) (point-max)))
 "C-S-p" 'execute-extended-command  ; M-x

 "<escape>" 'keyboard-escape-quit
 "<tab>" 'next-buffer
 "<backtab>" 'previous-buffer
 "?" 'consult-line

 "go" 'hop-word
 "gl" 'hop-char
 "gp" 'hop-regex-pattern
 "gk" 'hop-line)

(general-define-key
  :states 'normal
  :keymaps '(override org-mode-map)
  "<RET>" (lambda ()
            (interactive)
            (if (org-at-heading-p)
              (org-cycle)
              (if (org-in-regexp org-link-any-re)
                (org-open-at-point)
                (org-return)))))

(general-create-definer leader-key
  :states '(normal motion visual operator emacs)
  :keymaps '(override local global)
  :prefix "SPC")

(leader-key
  "reload" 'revert-buffer
  "ff" 'find-file
  "fr" 'consult-recent-file
  "tw" 'delete-trailing-whitespace
  "ev" 'eval-region
  "x" 'kill-this-buffer
  "c" 'display-fill-column-indicator-mode
  "s" 'switch-to-buffer
  "d" 'bookmark-jump
  "p" 'projectile-command-map
  "/" 'comment-dwim)
#+END_SRC


* Packages

** Productivity

*** Undo History

#+BEGIN_SRC emacs-lisp
;; keep undo history
(use-package undo-fu)
;; save command history
(use-package savehist
  :elpaca nil
  :init
  (savehist-mode))
;; keep file history between emacs sessions
(use-package undohist
  :init
  (setq undo-tree-history-directory-alist '(((concat user-emacs-directory "/undohist"))))
  :config
  (undohist-initialize))
#+END_SRC

*** Evil + General (Vim-Keybind)

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package evil
  :after undo-fu
  :init
  (setq evil-want-keybinding nil)
  (setq evil-undo-system 'undo-fu)
  :config
  (evil-mode 1)
  (setq ;evil-want-fine-undo t
   evil-want-minibuffer nil         ; <esc> works iirc
   evil-vsplit-window-right t
   evil-split-window-below t
   evil-cross-lines t))

(use-package helpful)
(use-package general
  :after (evil helpful hop consult)
  :config
  (general-override-mode)
  (general-auto-unbind-keys)
  (general-evil-setup t)

  ;; Remap C-h to helpful package
  (general-define-key
   :prefix "C-h"
   "f" #'helpful-callable
   "v" #'helpful-variable
   "k" #'helpful-key
   "F" #'helpful-function
   "C" #'helpful-command)
  <<general-config>>)
#+END_SRC

*** Vertico + Orderless (Autosuggestion & Fuzzy Finder)

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :init
  (setq vertico-count 20
        vertico-resize nil
        vertico-cycle t)
  (vertico-mode))

(use-package orderless
  :custom
  ;; (orderless-matching-styles '(orderless-literal orderless-regexp orderless-flex))
  (completion-styles '(orderless))
  (completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

*** Embark + Consult + Marginalia

- Embark: Quick Actions
- Consult: Extend default commands
- Marginalia: Add extra information on Variable/Function/FindFile/etc

#+BEGIN_SRC emacs-lisp
(use-package embark
  :bind ("C-;" . 'embark-act)
  :init
  (setq prefix-help-command #'embark-prefix-help-command
        embark-quit-after-action nil))

(use-package consult)
(use-package embark-consult)

(use-package marginalia
  :config
  (marginalia-mode)
  (setq marginalia-align 'center
        marginalia-align-offset 20))
#+END_SRC

*** Which Key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :init
  (which-key-mode)
  :config
  (setq which-key-idle-delay 0.4))
#+END_SRC

*** Hop (Jump Anywhere on Buffer)

#+BEGIN_SRC emacs-lisp
;; install pcre(-devel) package first from system package manager
;; (use-package pcre
;;   :elpaca (pcre :host github :repo "syohex/emacs-pcre"
;;                 :files (:default "pcre.el" "pcre-core.so")
;;                 :pre-build ("make" "all")))
;;
;; nix-managed install
(require 'pcre)

(use-package hop
  :elpaca (hop :host github :repo "Animeshz/hop.el"))
#+END_SRC

*** Chdir Support

Syncing /proc/self/cwd with changes to (default-directory).

#+BEGIN_SRC emacs-lisp
(require 'chdir)
#+END_SRC

** Customization

*** Theme

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (doom-themes-visual-bell-config)
  (load-theme 'doom-city-lights t)
  (custom-set-faces
   '(doom-themes-visual-bell (( t(:background "#00FFFF"))))
   '(org-ellipsis (( t(:foreground "#C678DD"))))))
#+END_SRC

*** Font

#+BEGIN_SRC emacs-lisp
(defvar try-fonts
  (list
   "CaskaydiaCove Nerd Font Mono"))
(defvar default-font nil
  "The default font")

(let ((try try-fonts))
  (while (and try (not (font-info (car try))))
    (setq try (cdr try)))
  (setq default-font (car try)))

(unless (eq default-font nil)
  (set-face-attribute 'default nil :font default-font))
(set-face-attribute 'default nil :height 125)
#+END_SRC

** Programming

*** Parinfer (Lisp Auto-Parenthesis)

#+BEGIN_SRC emacs-lisp
(use-package parinfer-rust-mode
  :hook '(emacs-lisp-mode)
  :init
  (setq parinfer-rust-auto-download t)
  (setq parinfer-rust-troublesome-modes nil)
  :config
  (defun my-enable-minor-mode-for-special-file ()
    "Enable my-minor-mode for my-special-file.txt."
    (message "%s" (buffer-name))
    (when (string= (buffer-name) "config.org")
      (parinfer-rust-mode)))
  (add-hook 'find-file-hook 'my-enable-minor-mode-for-special-file))
#+END_SRC

*** Highlighting

#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
(use-package markdown-mode
  :mode "\\.md\\'")
(use-package kotlin-mode
  :mode "\\.kt\\|\\.kts\\'")
#+END_SRC

*** AutoCompletion, CodeActions & Snippets

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (projectile-mode +1)
  :config
  (define-key projectile-command-map (kbd "ESC") 'keyboard-escape-quit))

; (use-package eglot
;   :hook (prog-mode . eglot-ensure)
;   :config
;   (add-to-list 'eglot-server-programs '(graphviz-dot-mode . ("dot-language-server" "--stdio"))))

(use-package corfu
  :elpaca (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*.el"))
  :config
  ;; Setup corfu for popup like completion
  (setq corfu-cycle t  ; Allows cycling through candidates
        corfu-auto t   ; Enable auto completion
        corfu-auto-prefix 0  ; Complete with less prefix keys
        corfu-auto-delay 0.0  ; No delay for completion
        corfu-echo-documentation t ; Echo docs for current completion option
        corfu-popupinfo-delay 0.0
        corfu-quit-no-match 'separator
        corfu-quit-at-boundary 'insert)

  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1))

(use-package tempel
  :config
  (global-tempel-abbrev-mode))

; (use-package tempel-collection)
#+END_SRC

*** Mermaid/GraphViz (Graph)

#+BEGIN_SRC emacs-lisp
(use-package mermaid-mode)
(use-package ob-mermaid
  :config
  (add-hook 'org-babel-after-execute-hook (lambda ()
                                            (org-redisplay-inline-images)))
  (setq org-startup-with-inline-images t)
  (setq org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages 'org-babel-load-languages '((mermaid . t))))

(use-package graphviz-dot-mode
  :config
  (org-babel-do-load-languages 'org-babel-load-languages '((dot . t))))

(use-package ob-svgbob)
#+END_SRC


* Misc

** Don't reset the cursor to the middle when scrolling

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(scroll-conservatively 200)
 '(scroll-margin 3))
#+END_SRC

** Highlight Trailing Whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
(add-hook 'prog-mode-hook
          (lambda () (font-lock-add-keywords nil '(("\\s-+$" 0 'trailing-whitespace)))))
#+END_SRC

** Don't affect previous line with C-backspace

#+BEGIN_SRC emacs-lisp
(defun my/backward-kill-word ()
  "Kill backward to the beginning of the current word, but do not cross lines."
  (interactive)
  (if (not (looking-back "^\\s-*")) (backward-kill-word 1) (delete-horizontal-space)))

(global-set-key (kbd "<C-backspace>") 'my/backward-kill-word)
#+END_SRC

** Change backup file dump path

#+BEGIN_SRC emacs-lisp
(defvar user-temporary-file-directory
  (concat temporary-file-directory user-login-name "/"))
(make-directory user-temporary-file-directory t)
(setq backup-by-copying t)
(setq backup-directory-alist
      `(("." . ,user-temporary-file-directory)
        (,tramp-file-name-regexp nil)))
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))
#+END_SRC

** Window Split Vertical-Horizontal Toggle

#+BEGIN_SRC emacs-lisp
(defun window-split-toggle ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (> (length (window-list)) 2)
      (error "Can't toggle with more than 2 windows!")
    (let ((func (if (window-full-height-p)
                    #'split-window-vertically
                  #'split-window-horizontally)))
      (delete-other-windows)
      (funcall func)
      (save-selected-window
        (other-window 1)
        (switch-to-buffer (other-buffer))))))
#+END_SRC

** open-at-point that opens respecting OS's default app for the link

#+BEGIN_SRC emacs-lisp
(defun open-at-point ()
  "Open URL at point."
  (interactive)
  (let* ((link-regexp "\\[\\[\\(.*?\\)\\]\\[.*?\\]\\]")
         (link (save-excursion
                 (when (re-search-backward link-regexp nil t)
                   (match-string 1)))))
    (message "%s" link)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" link t t)))
     ((string-equal system-type "darwin")
      (shell-command (format "open \"%s\"" link)))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" link))))))
#+END_SRC

** File closing prompt with evil-quit without saving won't show "Type C-h for help." in case wrong key is pressed.

Redefining the funcion at emacs/lisp/emacs-lisp/map-ynp.el, with some lines commented out.

#+BEGIN_SRC emacs-lisp
(defun map-y-or-n-p (prompter actor list &optional help action-alist
                     no-cursor-in-echo-area)
  "Ask a boolean question per PROMPTER for each object in LIST, then call ACTOR.

LIST is a list of objects, or a function of no arguments to return the next
object; when it returns nil, the list of objects is considered exhausted.

If PROMPTER is a string, it should be a format string to be used to format
the question as \(format PROMPTER OBJECT).
If PROMPTER is not a string, it should be a function of one argument, an
object from LIST, which returns a string to be used as the question for
that object.  If the function's return value is not a string, it may be
nil to ignore the object, or non-nil to act on the object with ACTOR
without asking the user.

ACTOR is a function of one argument, an object from LIST,
which gets called with each object for which the user answers `yes'
to the question presented by PROMPTER.

The user's answers to the questions may be one of the following:

 - y, Y, or SPC to act on that object;
 - n, N, or DEL to skip that object;
 - ! to act on all following objects;
 - ESC or q to exit (skip all following objects);
 - . (period) to act on the current object and then exit; or
 - \\[help-command] to get help.

HELP provides information for displaying help when the user
types \\[help-command].  If HELP is given, it should be a list of
the form (OBJECT OBJECTS ACTION), where OBJECT is a string giving
the singular noun describing an element of LIST; OBJECTS is the
plural noun describing several elements of LIST, and ACTION is a
transitive verb describing action by ACTOR on one or more elements
of LIST.  If HELP is omitted or nil, it defaults
to \(\"object\" \"objects\" \"act on\").

If ACTION-ALIST is given, it is an alist specifying additional keys
that will be accepted as an answer to the questions.  Each element
of the alist has the form (KEY FUNCTION HELP), where KEY is a character;
FUNCTION is a function of one argument (an object from LIST); and HELP
is a string.  When the user presses KEY, FUNCTION is called; if it
returns non-nil, the object is considered to have been \"acted upon\",
and `map-y-or-n-p' proceeds to the next object from LIST.  If
FUNCTION returns nil, the prompt is re-issued for the same object: this
comes in handy if FUNCTION produces some display that will allow the
user to make an intelligent decision whether the object in question
should be acted upon.  If the user types \\[help-command], the string
given by HELP is used to describe the effect of KEY.

Optional argument NO-CURSOR-IN-ECHO-AREA, if non-nil, means not to set
`cursor-in-echo-area' while prompting with the questions.

This function uses `query-replace-map' to define the standard responses,
but only some of the responses which `query-replace' understands
are meaningful here, as described above.

The function's value is the number of actions taken."
  (let* ((actions 0)
         (msg (current-message))
         user-keys mouse-event map prompt char elt def
   ;; Non-nil means we should use mouse menus to ask.
         use-menus
         delayed-switch-frame
         ;; Rebind other-window-scroll-buffer so that subfunctions can set
         ;; it temporarily, without risking affecting the caller.
         (other-window-scroll-buffer other-window-scroll-buffer)
         (next (if (functionp list)
                   (lambda () (setq elt (funcall list)))
                   (lambda () (when list
                               (setq elt (pop list))
                               t))))
         (try-again (lambda ()
                     (let ((x next))
                      (setq next (lambda () (setq next x) elt))))))
    (if (and (listp last-nonmenu-event)
         use-dialog-box)
  ;; Make a list describing a dialog box.
     (let ((objects (if help (capitalize (nth 1 help))))
           (action (if help (capitalize (nth 2 help)))))
      (setq map `(("Yes" . act) ("No" . skip)
                  ,@(mapcar (lambda (elt)
                             (cons (with-syntax-table
                                    text-mode-syntax-table
                                    (capitalize (nth 2 elt)))
                              (vector (nth 1 elt))))
                     action-alist)
                  (,(if help (concat action " This But No More")
                     "Do This But No More") . act-and-exit)
                  (,(if help (concat action " All " objects)
                     "Do All") . automatic)
                  ("No For All" . exit))
       use-menus t
       mouse-event last-nonmenu-event))
     (setq user-keys (if action-alist
                      (concat (mapconcat (lambda (elt)
                                                 (key-description
                                                  (vector (car elt))))
                               action-alist ", ")
                       " ")
                      "")
     ;; Make a map that defines each user key as a vector containing
     ;; its definition.
      map
           (let ((map (make-sparse-keymap)))
             (set-keymap-parent map query-replace-map)
             (dolist (elt action-alist)
               (define-key map (vector (car elt)) (vector (nth 1 elt))))
             map)))
    (unwind-protect
     (progn
      (if (stringp prompter)
       (setq prompter (let ((prompter prompter))
                       (lambda (object)
                        (format prompter object)))))
      (while (funcall next)
       (setq prompt (funcall prompter elt))
       (cond ((stringp prompt)
      ;; Prompt the user about this object.
              (setq quit-flag nil)
              (if use-menus
               (setq def (or (x-popup-dialog (or mouse-event use-menus)
                              (cons prompt map))
                          'quit))
       ;; Prompt in the echo area.
               (let ((cursor-in-echo-area (not no-cursor-in-echo-area)))
                (message (apply 'propertize "%s(y, n, !, ., q, %sor %s) "
                          minibuffer-prompt-properties)
                 prompt user-keys
                 (key-description (vector help-char)))
                (if minibuffer-auto-raise
                 (raise-frame (window-frame (minibuffer-window))))
                (while (progn
                        (setq char (read-event))
      ;; If we get -1, from end of keyboard
      ;; macro, try again.
                        (equal char -1)))
         ;; Show the answer to the question.
                (message "%s(y, n, !, ., q, %sor %s) %s"
                 prompt user-keys
                 (key-description (vector help-char))
                 (single-key-description char)))
               (setq def (lookup-key map (vector char))))
              (cond ((eq def 'exit)
                     (setq next (lambda () nil)))
               ((eq def 'act)
      ;; Act on the object.
                (funcall actor elt)
                (setq actions (1+ actions)))
               ((eq def 'skip))
      ;; Skip the object.

               ((eq def 'act-and-exit)
      ;; Act on the object and then exit.
                (funcall actor elt)
                (setq actions (1+ actions)
                 next (lambda () nil)))
               ((eq def 'quit)
                (setq quit-flag t)
                (funcall try-again))
               ((eq def 'automatic)
      ;; Act on this and all following objects.
                (if (funcall prompter elt)
                 (progn
                  (funcall actor elt)
                  (setq actions (1+ actions))))
                (while (funcall next)
                 (if (funcall prompter elt)
                  (progn
                   (funcall actor elt)
                   (setq actions (1+ actions))))))
               ((eq def 'help)
                (with-help-window (help-buffer)
                 (princ
                           (let ((object  (or (nth 0 help) "object"))
                                 (objects (or (nth 1 help) "objects"))
                                 (action  (or (nth 2 help) "act on")))
                            (concat
                                      (format-message
                                       (substitute-command-keys "\
Type \\`SPC' or \\`y' to %s the current %s;
\\`DEL' or \\`n' to skip the current %s;
\\`RET' or \\`q' to skip the current and all remaining %s;
\\`C-g' to quit (cancel the whole command);
\\`!' to %s all remaining %s;\n")
                                       action object object objects action objects)
                                      (mapconcat (lambda (elt)
                                                   (format "%s to %s;\n"
                                                           (single-key-description
                                                            (nth 0 elt))
                                                           (nth 2 elt)))
                                       action-alist
                                                 "")
                                      (format
                                       "or . (period) to %s the current %s and exit."
                                       action object)))))

                (funcall try-again))
               ((and (symbolp def) (commandp def))
                (call-interactively def)
      ;; Regurgitated; try again.
                (funcall try-again))
               ((vectorp def)
      ;; A user-defined key.
                (if (funcall (aref def 0) elt) ;Call its function.
          ;; The function has eaten this object.
                 (setq actions (1+ actions))
        ;; Regurgitated; try again.
                 (funcall try-again)))
               ((and (consp char)
                 (eq (car char) 'switch-frame))
      ;; switch-frame event.  Put it off until we're done.
                (setq delayed-switch-frame char)
                (funcall try-again))))
      ;; (t
      ;; Random char.
      ;; (message "Type %s for help."
      ;;      (key-description (vector help-char)))
      ;; (beep)
      ;; (sit-for 1)
      ;; (funcall try-again))))
        (prompt
         (funcall actor elt)
         (setq actions (1+ actions))))))
     (if delayed-switch-frame
      (setq unread-command-events
       (cons delayed-switch-frame unread-command-events))))
    ;; Clear the last prompt from the minibuffer, and restore the
    ;; previous echo-area message, if any.
    (let ((message-log-max nil))
      (if msg
          (message "%s" msg)
        (message "")))
    ;; Return the number of actions that were taken.
    actions))
#+END_SRC

* Resources References

These resources were very helpful in formation of my config. So a huge phrase of appreciation to all those people who were part of this.

- [[https://opensource.com/sites/default/files/gated-content/cheat_sheet_emacs.pdf][Emacs Cheatsheet - Opensource.com]]
- [[https://github.com/progfolio/.emacs.d][Progfolio's Emacs Config (Creator of Elpaca package manager we're currently using)]]
- [[https://github.com/aadi58002/emacs-config/blob/main/init.org#avy-map][Aadi58002's Emacs Config (My classmate, been known for the Emacs user of our batch)]]
- [[https://www.lucacambiaghi.com/vanilla-emacs/readme.html][Luca's Emacs Config]] & [[https://www.karsdorp.io/posts/dotemacs/][Karsdorp's Emacs Config]] - Long list of useful options to use, like a reference-book!
